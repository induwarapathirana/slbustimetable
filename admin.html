<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Bus Timetable</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .sortable-ghost { opacity: 0.4; background: #c8ebfb; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="bg-gray-100">

    <div id="config-warning" class="hidden bg-yellow-100 border border-yellow-200 text-yellow-900 px-4 py-3 text-sm text-center">
        Firebase configuration is missing. Update <code>firebaseConfig</code> before using the admin dashboard.
    </div>

    <div id="login-screen" class="min-h-screen flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
            <h2 class="text-2xl font-bold text-center mb-6">Admin Panel Login</h2>
            <form id="login-form" class="space-y-4">
                <div>
                    <label for="email" class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="email" autocomplete="email" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
                </div>
                <div>
                    <label for="password" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="password" autocomplete="current-password" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
                </div>
                <button type="submit" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Login</button>
                <p id="login-error" class="text-red-500 text-sm text-center"></p>
            </form>
        </div>
    </div>

    <div id="dashboard" class="hidden">
        <header class="bg-white shadow-md">
            <nav class="container mx-auto px-4 py-4 flex justify-between items-center">
                <h1 class="text-xl font-bold">Bus Schedule Management</h1>
                <div>
                    <a href="/user_management.html" class="text-indigo-600 hover:underline mr-4 font-semibold">Manage Users</a>
                    <button id="logout-button" class="bg-red-500 text-white py-2 px-4 rounded-md hover:bg-red-600">Logout</button>
                </div>
            </nav>
        </header>

        <main class="container mx-auto p-4 md:p-6">
            <div id="action-message" class="hidden mb-6">
                <p id="action-message-text" class="px-4 py-3 rounded-md text-sm font-medium border"></p>
            </div>
            <div class="flex flex-col md:flex-row md:justify-between md:items-center gap-4 mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Current Bus Timetable</h2>
                    <p class="text-gray-600">Manage the central SQLite-backed timetable via the secured API.</p>
                </div>
                <div class="flex gap-3">
                    <button id="show-add-modal" class="bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 shadow">Add Single Bus</button>
                    <button id="show-bulk-add-modal" class="bg-green-500 text-white py-2 px-4 rounded-md hover:bg-green-600 shadow">Bulk Add by Frequency</button>
                    <button id="refresh-button" class="bg-slate-200 text-slate-700 py-2 px-4 rounded-md hover:bg-slate-300 shadow">Refresh</button>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-md mb-6">
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
                    <div>
                        <h2 class="text-2xl font-bold">Price Matrix</h2>
                        <p class="text-sm text-gray-500">Maintain reusable fare presets and departure locations for quick bus creation.</p>
                    </div>
                    <div class="flex items-center gap-2 text-sm text-gray-500">
                        <span class="inline-flex items-center justify-center w-2.5 h-2.5 rounded-full bg-green-500"></span>
                        <span>Updates sync instantly with all admin and timekeeper tools.</span>
                    </div>
                </div>

                <form id="price-matrix-form" class="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-3">
                    <input list="location-options" type="text" id="price-origin" class="w-full p-2 border rounded" placeholder="Origin (e.g., Makumbura)" required>
                    <input list="location-options" type="text" id="price-destination" class="w-full p-2 border rounded" placeholder="Destination (e.g., Galle)" required>
                    <input type="text" id="price-amount" class="w-full p-2 border rounded" placeholder="Price (e.g., 1200 LKR)" required>
                    <div class="flex gap-2">
                        <button type="submit" class="flex-1 bg-indigo-600 text-white py-2 rounded-md hover:bg-indigo-700">Save</button>
                        <button type="button" id="price-form-reset" class="flex-1 border border-gray-300 text-gray-700 py-2 rounded-md hover:bg-gray-50">Clear</button>
                    </div>
                    <p id="price-form-message" class="md:col-span-2 lg:col-span-1 text-sm font-medium"></p>
                    <input type="hidden" id="price-entry-id">
                </form>

                <div id="price-matrix-empty" class="hidden text-center text-gray-500 py-6">No price entries yet. Add your first fare preset above.</div>
                <div class="overflow-x-auto mt-4">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50 text-xs font-semibold uppercase tracking-wide text-gray-500">
                            <tr>
                                <th class="px-4 py-3 text-left">Origin</th>
                                <th class="px-4 py-3 text-left">Destination</th>
                                <th class="px-4 py-3 text-left">Price</th>
                                <th class="px-4 py-3 text-left">Last Updated</th>
                                <th class="px-4 py-3 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="price-matrix-body" class="bg-white divide-y divide-gray-200 text-sm"></tbody>
                    </table>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold">Timetable</h3>
                    <span id="last-updated" class="text-sm text-gray-500"></span>
                </div>
                <div id="loading" class="text-center py-10">Loading timetable...</div>
                <div id="bus-list-container" class="overflow-x-auto hidden">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Order</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Route</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Departure</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Arrival</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Days</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="bus-table-body" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                <p id="bus-empty-state" class="hidden text-center text-gray-500 py-6">No buses in the timetable yet.</p>
            </div>

            <section class="mt-8">
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-6">
                        <div>
                            <h3 class="text-xl font-semibold">Price Matrix & Destinations</h3>
                            <p class="text-gray-600 text-sm">Maintain official destinations and fare presets. New entries instantly power autocomplete fields.</p>
                        </div>
                        <button id="refresh-matrix" class="self-start md:self-auto bg-slate-100 text-slate-700 px-4 py-2 rounded-md hover:bg-slate-200">Refresh Matrix</button>
                    </div>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="space-y-4">
                            <div>
                                <h4 class="text-lg font-semibold mb-2">Destinations</h4>
                                <form id="location-form" class="flex gap-2">
                                    <input type="text" id="location-name" placeholder="Add new destination" class="flex-1 p-2 border rounded" required>
                                    <button type="submit" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Add</button>
                                </form>
                                <p id="location-message" class="text-sm mt-2"></p>
                            </div>
                            <div id="location-list" class="max-h-64 overflow-y-auto border border-gray-200 rounded-md divide-y"></div>
                        </div>
                        <div class="space-y-4">
                            <div>
                                <h4 class="text-lg font-semibold mb-2">Quick Fare Entry</h4>
                                <form id="fare-form" class="grid grid-cols-1 md:grid-cols-3 gap-3">
                                    <input type="text" id="fare-origin" list="locations-list" placeholder="Origin" class="p-2 border rounded" required>
                                    <input type="text" id="fare-destination" list="locations-list" placeholder="Destination" class="p-2 border rounded" required>
                                    <input type="text" id="fare-price" placeholder="Price (e.g., 1200 LKR)" class="p-2 border rounded" required>
                                    <button type="submit" class="md:col-span-3 bg-green-600 text-white py-2 rounded-md hover:bg-green-700">Save Fare</button>
                                </form>
                                <p id="fare-message" class="text-sm mt-2"></p>
                            </div>
                            <div class="border border-gray-200 rounded-md overflow-hidden">
                                <table class="min-w-full text-sm">
                                    <thead class="bg-gray-50 text-gray-600 uppercase tracking-wide text-xs">
                                        <tr>
                                            <th class="px-3 py-2 text-left">Origin</th>
                                            <th class="px-3 py-2 text-left">Destination</th>
                                            <th class="px-3 py-2 text-left">Price</th>
                                            <th class="px-3 py-2 text-right">Updated</th>
                                        </tr>
                                    </thead>
                                    <tbody id="fare-table" class="divide-y"></tbody>
                                </table>
                                <p id="fare-empty" class="hidden text-sm text-gray-500 text-center py-4">No fares yet. Add your first pairing above.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <datalist id="location-options"></datalist>

    <!-- Add/Edit Modal -->
    <div id="bus-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-10 mx-auto p-5 border w-full max-w-3xl shadow-lg rounded-md bg-white">
            <div class="flex justify-between items-center pb-3">
                <p id="modal-title" class="text-2xl font-bold">Add New Bus</p>
                <button id="close-modal" class="cursor-pointer z-50">
                    <svg class="fill-current text-black" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path d="M14.53 4.53l-1.06-1.06L9 7.94 4.53 3.47 3.47 4.53 7.94 9l-4.47 4.47 1.06 1.06L9 10.06l4.47 4.47 1.06-1.06L10.06 9z"></path></svg>
                </button>
            </div>
            <form id="bus-form" class="space-y-4 max-h-[70vh] overflow-y-auto pr-2">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <input type="text" placeholder="Route (e.g., EX1/01)" id="route" class="w-full p-2 border rounded" required>
                    <input type="text" placeholder="Operator" id="operator" class="w-full p-2 border rounded" required>
                    <input type="text" placeholder="Departs From" id="departsFrom" class="w-full p-2 border rounded" list="location-options" required>
                    <input type="text" placeholder="Arrives At" id="arrivesAt" class="w-full p-2 border rounded" list="location-options" required>
                    <input type="time" placeholder="Departure Time" id="departureTime" class="w-full p-2 border rounded" required>
                    <input type="time" placeholder="Arrival Time" id="arrivalTime" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Price (e.g., 1200 LKR)" id="price" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Expressway Entrance" id="expresswayEntrance" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Expressway Exit" id="expresswayExit" class="w-full p-2 border rounded">
                </div>
                <div>
                    <label class="font-bold">Availability (Days of the Week)</label>
                    <div id="availability-checkboxes" class="grid grid-cols-2 md:grid-cols-4 gap-2 mt-2"></div>
                </div>
                <div>
                    <label class="font-bold">Intermediate Stops (one per line)</label>
                    <textarea id="stops" rows="4" class="w-full p-2 border rounded mt-2"></textarea>
                </div>
                <input type="hidden" id="bus-id">
                <div class="flex justify-between items-center">
                    <p id="form-error" class="text-sm text-red-500"></p>
                    <button type="submit" class="bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600">Save Bus</button>
                </div>
            </form>
        </div>
    </div>

    <div id="bulk-add-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-10 mx-auto p-5 border w-full max-w-3xl shadow-lg rounded-md bg-white">
            <div class="flex justify-between items-center pb-3">
                <p class="text-2xl font-bold">Bulk Add Buses by Frequency</p>
                <button id="close-bulk-modal" class="cursor-pointer z-50">
                    <svg class="fill-current text-black" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path d="M14.53 4.53l-1.06-1.06L9 7.94 4.53 3.47 3.47 4.53 7.94 9l-4.47 4.47 1.06 1.06L9 10.06l4.47 4.47 1.06-1.06L10.06 9z"></path></svg>
                </button>
            </div>
            <form id="bulk-bus-form" class="space-y-4 max-h-[70vh] overflow-y-auto pr-2">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <input type="text" placeholder="Route (e.g., EX1)" id="bulk-route" class="w-full p-2 border rounded" required>
                    <input type="text" placeholder="Operator" id="bulk-operator" class="w-full p-2 border rounded" required>
                    <input type="text" placeholder="Departs From" id="bulk-departsFrom" class="w-full p-2 border rounded" list="location-options" required>
                    <input type="text" placeholder="Arrives At" id="bulk-arrivesAt" class="w-full p-2 border rounded" list="location-options" required>
                    <input type="text" placeholder="Price" id="bulk-price" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Expressway Entrance" id="bulk-expresswayEntrance" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Expressway Exit" id="bulk-expresswayExit" class="w-full p-2 border rounded">
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-4 bg-gray-50 rounded-md">
                    <div>
                        <label for="bulk-startTime" class="font-semibold block text-sm">Start Time</label>
                        <input type="time" id="bulk-startTime" class="w-full p-2 border rounded" required>
                    </div>
                    <div>
                        <label for="bulk-endTime" class="font-semibold block text-sm">End Time</label>
                        <input type="time" id="bulk-endTime" class="w-full p-2 border rounded" required>
                    </div>
                    <div>
                        <label for="bulk-frequency" class="font-semibold block text-sm">Frequency (mins)</label>
                        <input type="number" id="bulk-frequency" class="w-full p-2 border rounded" placeholder="e.g., 30" required>
                    </div>
                    <div>
                        <label for="bulk-duration" class="font-semibold block text-sm">Travel Duration (mins)</label>
                        <input type="number" id="bulk-duration" class="w-full p-2 border rounded" placeholder="e.g., 90" required>
                    </div>
                </div>
                <div>
                    <label class="font-bold">Availability (Days of the Week)</label>
                    <div id="bulk-availability-checkboxes" class="grid grid-cols-2 md:grid-cols-4 gap-2 mt-2"></div>
                </div>
                <div>
                    <label class="font-bold">Intermediate Stops (one per line)</label>
                    <textarea id="bulk-stops" rows="3" class="w-full p-2 border rounded mt-2"></textarea>
                </div>
                <p id="bulk-add-message" class="text-sm font-medium"></p>
                <button type="submit" class="w-full bg-green-500 text-white py-2 rounded-md hover:bg-green-600">Generate and Add Buses</button>
            </form>
        </div>
    </div>

        <script type="module">
    import { getApp, getApps, initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import {
        getFirestore,
        addDoc,
        collection,
        deleteDoc,
        doc,
        getDoc,
        getDocs,
        limit,
        onSnapshot,
        orderBy,
        query,
        serverTimestamp,
        setDoc,
        where
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyArXmYmU6l4t_xaNquhT0JUH4sG2ge3tZo",
        authDomain: "bustimetable-v2.firebaseapp.com",
        projectId: "bustimetable-v2",
        storageBucket: "bustimetable-v2.firebasestorage.app",
        messagingSenderId: "665985152111",
        appId: "1:665985152111:web:291020ebb619374c4f899a",
        measurementId: "G-0EEKT7RR6R"
    };

    const configWarning = document.getElementById('config-warning');
    if (!firebaseConfig.apiKey) {
        if (configWarning) {
            configWarning.classList.remove('hidden');
        }
        console.warn('Firebase configuration is missing. Admin dashboard halted.');
    } else {
        const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const loginScreen = document.getElementById('login-screen');
        const dashboard = document.getElementById('dashboard');
        const loginForm = document.getElementById('login-form');
        const logoutButton = document.getElementById('logout-button');
        const refreshButton = document.getElementById('refresh-button');

        const busListContainer = document.getElementById('bus-list-container');
        const busTableBody = document.getElementById('bus-table-body');
        const busEmptyState = document.getElementById('bus-empty-state');
        const lastUpdatedLabel = document.getElementById('last-updated');
        const loading = document.getElementById('loading');

        const busModal = document.getElementById('bus-modal');
        const modalTitle = document.getElementById('modal-title');
        const closeModalButton = document.getElementById('close-modal');
        const showAddModalButton = document.getElementById('show-add-modal');
        const busForm = document.getElementById('bus-form');
        const busIdInput = document.getElementById('bus-id');
        const formError = document.getElementById('form-error');
        const availabilityContainer = document.getElementById('availability-checkboxes');
        const stopsTextarea = document.getElementById('stops');

        const routeInput = document.getElementById('route');
        const operatorInput = document.getElementById('operator');
        const departsFromInput = document.getElementById('departsFrom');
        const arrivesAtInput = document.getElementById('arrivesAt');
        const departureTimeInput = document.getElementById('departureTime');
        const arrivalTimeInput = document.getElementById('arrivalTime');
        const priceInput = document.getElementById('price');
        const expresswayEntranceInput = document.getElementById('expresswayEntrance');
        const expresswayExitInput = document.getElementById('expresswayExit');

        const bulkAddModal = document.getElementById('bulk-add-modal');
        const showBulkAddModalButton = document.getElementById('show-bulk-add-modal');
        const closeBulkModalButton = document.getElementById('close-bulk-modal');
        const bulkBusForm = document.getElementById('bulk-bus-form');
        const bulkAddMessage = document.getElementById('bulk-add-message');
        const bulkAvailabilityContainer = document.getElementById('bulk-availability-checkboxes');
        const bulkStopsTextarea = document.getElementById('bulk-stops');
        const bulkRouteInput = document.getElementById('bulk-route');
        const bulkOperatorInput = document.getElementById('bulk-operator');
        const bulkDepartsFromInput = document.getElementById('bulk-departsFrom');
        const bulkArrivesAtInput = document.getElementById('bulk-arrivesAt');
        const bulkPriceInput = document.getElementById('bulk-price');
        const bulkExpresswayEntranceInput = document.getElementById('bulk-expresswayEntrance');
        const bulkExpresswayExitInput = document.getElementById('bulk-expresswayExit');
        const bulkStartTimeInput = document.getElementById('bulk-startTime');
        const bulkEndTimeInput = document.getElementById('bulk-endTime');
        const bulkFrequencyInput = document.getElementById('bulk-frequency');
        const bulkDurationInput = document.getElementById('bulk-duration');

        const priceForm = document.getElementById('price-matrix-form');
        const priceOriginInput = document.getElementById('price-origin');
        const priceDestinationInput = document.getElementById('price-destination');
        const priceAmountInput = document.getElementById('price-amount');
        const priceEntryIdInput = document.getElementById('price-entry-id');
        const priceFormMessage = document.getElementById('price-form-message');
        const priceFormReset = document.getElementById('price-form-reset');
        const priceMatrixBody = document.getElementById('price-matrix-body');
        const priceMatrixEmpty = document.getElementById('price-matrix-empty');
        const locationOptionsList = document.getElementById('location-options');
        const refreshMatrixButton = document.getElementById('refresh-matrix');
        const actionMessageContainer = document.getElementById('action-message');
        const actionMessageText = document.getElementById('action-message-text');

        const daysOfWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

        let currentUser = null;
        let unsubscribe = null;
        let priceMatrixUnsubscribe = null;
        let priceAutoFillRegistered = false;

        const state = {
            buses: [],
            sortable: null
        };
        let apiTokenPromise = null;

        const actionMessageVariants = {
            info: 'bg-blue-50 text-blue-700 border-blue-200',
            success: 'bg-green-50 text-green-700 border-green-200',
            warning: 'bg-yellow-50 text-yellow-700 border-yellow-200',
            error: 'bg-red-50 text-red-700 border-red-200'
        };

        function showActionMessage(message, variant = 'info') {
            if (!actionMessageContainer || !actionMessageText) return;
            const classes = actionMessageVariants[variant] || actionMessageVariants.info;
            actionMessageText.textContent = message;
            actionMessageText.className = `px-4 py-3 rounded-md text-sm font-medium border ${classes}`;
            actionMessageContainer.classList.remove('hidden');
        }

        function clearActionMessage() {
            if (!actionMessageContainer || !actionMessageText) return;
            actionMessageText.textContent = '';
            actionMessageText.className = 'px-4 py-3 rounded-md text-sm font-medium border';
            actionMessageContainer.classList.add('hidden');
        }

        function describeError(error, fallback = 'Unexpected error occurred.') {
            if (!error) return fallback;
            if (typeof error === 'string') return error;
            if (error instanceof Error) {
                return error.message || fallback;
            }
            if (typeof error === 'object' && 'message' in error && error.message) {
                return error.message;
            }
            try {
                return JSON.stringify(error);
            } catch {
                return fallback;
            }
        }

        async function getApiToken(forceRefresh = false) {
            if (!currentUser) {
                throw new Error('Authentication required. Please sign in again.');
            }
            if (!forceRefresh && apiTokenPromise) {
                return apiTokenPromise;
            }
            apiTokenPromise = (async () => {
                const idToken = await currentUser.getIdToken(forceRefresh);
                const response = await fetch('/api/firebase-login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                    body: JSON.stringify({ idToken })
                });
                const data = await response.json().catch(() => null);
                if (!response.ok || !data?.token) {
                    const message = (Array.isArray(data?.errors) && data.errors.length)
                        ? data.errors.join(', ')
                        : data?.message || 'Failed to authorize with the API.';
                    throw new Error(message);
                }
                return data.token;
            })();
            try {
                return await apiTokenPromise;
            } catch (error) {
                apiTokenPromise = null;
                throw error;
            }
        }

        async function fetchWithAuth(url, options = {}, retry = true) {
            if (!currentUser) {
                throw new Error('Authentication required. Please sign in again.');
            }
            const headers = new Headers(options.headers || {});
            if (options.body && !(options.body instanceof FormData) && !headers.has('Content-Type')) {
                headers.set('Content-Type', 'application/json');
            }
            if (!headers.has('Accept')) {
                headers.set('Accept', 'application/json');
            }
            const token = await getApiToken(retry ? false : true);
            headers.set('Authorization', `Bearer ${token}`);
            const response = await fetch(url, { ...options, headers });
            if (response.status === 401 && retry) {
                apiTokenPromise = null;
                return fetchWithAuth(url, options, false);
            }
            return response;
        }

        const priceLookup = new Map();
        const priceEntryByKey = new Map();
        const locationSet = new Set();

        function renderAvailabilityCheckboxes(container) {
            if (!container) return;
            container.innerHTML = '';
            daysOfWeek.forEach(day => {
                const label = document.createElement('label');
                label.className = 'flex items-center gap-2 text-sm';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = day;
                checkbox.className = 'rounded border-gray-300 text-indigo-600 focus:ring-indigo-500';
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(day));
                container.appendChild(label);
            });
        }

        function setSelectedDays(container, values = []) {
            if (!container) return;
            const selected = new Set(values.map(value => value.toString()));
            container.querySelectorAll('input[type="checkbox"]').forEach(input => {
                input.checked = selected.has(input.value);
            });
        }

        function getSelectedDays(container) {
            if (!container) return [];
            return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(input => input.value);
        }

        function parseStops(value) {
            return value
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(Boolean);
        }

        function resetBusForm() {
            if (!busForm) return;
            busForm.reset();
            if (busIdInput) busIdInput.value = '';
            if (formError) formError.textContent = '';
            delete busForm.dataset.busId;
            delete busForm.dataset.originalStatus;
            delete busForm.dataset.originalSortOrder;
            setSelectedDays(availabilityContainer, []);
        }

        function openModal(title, data = {}, busId = '') {
            if (!busModal || !busForm) return;
            resetBusForm();
            modalTitle.textContent = title;
            busModal.classList.remove('hidden');
            if (busId) {
                busForm.dataset.busId = busId;
                if (typeof data.status !== 'undefined') {
                    busForm.dataset.originalStatus = data.status;
                }
                if (typeof data.sortOrder !== 'undefined') {
                    busForm.dataset.originalSortOrder = data.sortOrder;
                }
            }
            if (routeInput) routeInput.value = data.route || '';
            if (operatorInput) operatorInput.value = data.operator || '';
            if (departsFromInput) departsFromInput.value = data.departsFrom || '';
            if (arrivesAtInput) arrivesAtInput.value = data.arrivesAt || '';
            if (departureTimeInput) departureTimeInput.value = data.departureTime || '';
            if (arrivalTimeInput) arrivalTimeInput.value = data.arrivalTime || '';
            if (priceInput) priceInput.value = data.price || '';
            if (expresswayEntranceInput) expresswayEntranceInput.value = data.expresswayEntrance || '';
            if (expresswayExitInput) expresswayExitInput.value = data.expresswayExit || '';
            if (stopsTextarea) stopsTextarea.value = Array.isArray(data.stops) ? data.stops.join('\n') : '';
            setSelectedDays(availabilityContainer, Array.isArray(data.availability) ? data.availability : []);
        }

        function closeBusModal() {
            if (!busModal) return;
            busModal.classList.add('hidden');
            resetBusForm();
        }

        function closeBulkModal() {
            if (!bulkAddModal) return;
            bulkAddModal.classList.add('hidden');
            if (bulkAddMessage) {
                bulkAddMessage.textContent = '';
                bulkAddMessage.className = 'text-sm font-medium';
            }
            if (bulkBusForm) {
                bulkBusForm.reset();
            }
            setSelectedDays(bulkAvailabilityContainer, []);
        }

        function collectBusFormData() {
            if (!routeInput || !operatorInput || !departsFromInput || !arrivesAtInput || !departureTimeInput) {
                return null;
            }

            const route = routeInput.value.trim();
            const operator = operatorInput.value.trim();
            const departsFrom = departsFromInput.value.trim();
            const arrivesAt = arrivesAtInput.value.trim();
            const departureTime = departureTimeInput.value.trim();

            if (!route || !operator || !departsFrom || !arrivesAt || !departureTime) {
                if (formError) {
                    formError.textContent = 'Please complete all required fields.';
                }
                showActionMessage('Please complete all required bus fields before saving.', 'error');
                return null;
            }

            return {
                route,
                operator,
                departsFrom,
                arrivesAt,
                departureTime,
                arrivalTime: arrivalTimeInput ? arrivalTimeInput.value.trim() : '',
                price: priceInput ? priceInput.value.trim() : '',
                expresswayEntrance: expresswayEntranceInput ? expresswayEntranceInput.value.trim() : '',
                expresswayExit: expresswayExitInput ? expresswayExitInput.value.trim() : '',
                availability: getSelectedDays(availabilityContainer),
                stops: parseStops(stopsTextarea ? stopsTextarea.value : '')
            };
        }

        function renderStatusPill(status) {
            const map = {
                Scheduled: 'bg-gray-100 text-gray-700',
                Departed: 'bg-green-100 text-green-700',
                Arrived: 'bg-blue-100 text-blue-700',
                Delayed: 'bg-yellow-100 text-yellow-700',
                Cancelled: 'bg-red-100 text-red-700'
            };
            const classes = map[status] || map.Scheduled;
            return `<span class="px-2 py-1 rounded-full ${classes}">${status || 'Scheduled'}</span>`;
        }

        function renderBusTable(buses) {
            state.buses = Array.isArray(buses) ? buses : [];

            if (loading) {
                loading.classList.add('hidden');
            }

            if (!busTableBody) return;
            busTableBody.innerHTML = '';

            if (!state.buses.length) {
                if (busListContainer) busListContainer.classList.add('hidden');
                if (busEmptyState) busEmptyState.classList.remove('hidden');
                if (lastUpdatedLabel) lastUpdatedLabel.textContent = '';
            } else {
                const fragment = document.createDocumentFragment();
                state.buses.forEach((bus, index) => {
                    const tr = document.createElement('tr');
                    tr.dataset.id = bus.id;
                    tr.innerHTML = `
                        <td class="px-4 py-3 text-sm text-gray-500 font-medium cursor-move">${index + 1}</td>
                        <td class="px-4 py-3">
                            <div class="font-semibold text-gray-800">${bus.route || '—'}</div>
                            <div class="text-sm text-gray-500">${bus.operator || ''}</div>
                        </td>
                        <td class="px-4 py-3 text-sm text-gray-700">
                            <div class="font-medium">${bus.departsFrom || '—'}</div>
                            <div class="text-xs text-gray-500">${bus.departureTime || '—'}</div>
                        </td>
                        <td class="px-4 py-3 text-sm text-gray-700">
                            <div class="font-medium">${bus.arrivesAt || '—'}</div>
                            <div class="text-xs text-gray-500">${bus.arrivalTime || '—'}</div>
                        </td>
                        <td class="px-4 py-3 text-xs text-gray-600">${Array.isArray(bus.availability) ? bus.availability.join(', ') : '—'}</td>
                        <td class="px-4 py-3 text-sm">${renderStatusPill(bus.status)}</td>
                        <td class="px-4 py-3 text-right text-sm font-medium">
                            <button class="text-indigo-600 hover:text-indigo-900 edit-btn" data-id="${bus.id}">Edit</button>
                            <button class="text-red-600 hover:text-red-900 ml-4 delete-btn" data-id="${bus.id}">Delete</button>
                        </td>`;

                    const editButton = tr.querySelector('.edit-btn');
                    const deleteButton = tr.querySelector('.delete-btn');
                    if (editButton) {
                        editButton.addEventListener('click', () => handleEditBus(bus.id));
                    }
                    if (deleteButton) {
                        deleteButton.addEventListener('click', () => handleDeleteBus(bus.id));
                    }
                    fragment.appendChild(tr);
                });
                busTableBody.appendChild(fragment);
                if (busListContainer) busListContainer.classList.remove('hidden');
                if (busEmptyState) busEmptyState.classList.add('hidden');
                if (lastUpdatedLabel) lastUpdatedLabel.textContent = `Last updated ${new Date().toLocaleString()}`;
            }

            if (state.sortable) {
                state.sortable.destroy();
                state.sortable = null;
            }

            if (state.buses.length && busTableBody) {
                state.sortable = new Sortable(busTableBody, {
                    animation: 150,
                    handle: 'td:first-child',
                    ghostClass: 'sortable-ghost',
                    onEnd: handleReorder
                });
            }
        }

        async function loadBuses() {
            if (!currentUser) return;
            if (loading) {
                loading.textContent = 'Loading timetable...';
                loading.classList.remove('hidden');
            }
            try {
                const response = await fetchWithAuth('/api/buses');
                const data = await response.json().catch(() => null);
                if (!response.ok || !Array.isArray(data)) {
                    const message = (Array.isArray(data?.errors) && data.errors.length)
                        ? data.errors.join(', ')
                        : data?.message || 'Failed to load timetable.';
                    throw new Error(message);
                }
                renderBusTable(data);
            } catch (error) {
                console.error('Error fetching buses:', error);
                showActionMessage(`Failed to load timetable: ${describeError(error)}`, 'error');
                if (loading) {
                    loading.textContent = 'Error loading data. Check console.';
                    loading.classList.remove('hidden');
                }
            }
        }

        async function handleReorder() {
            if (!busTableBody) return;
            const orderedIds = Array.from(busTableBody.querySelectorAll('tr'))
                .map(row => row.dataset.id)
                .filter(Boolean);

            if (!orderedIds.length) {
                return;
            }

            const currentOrderMatches = orderedIds.every((id, index) => state.buses[index]?.id === id);
            if (currentOrderMatches) {
                return;
            }

            try {
                const response = await fetchWithAuth('/api/buses/order', {
                    method: 'POST',
                    body: JSON.stringify({ orderedIds })
                });
                const data = await response.json().catch(() => null);
                if (!response.ok) {
                    const message = (Array.isArray(data?.errors) && data.errors.length)
                        ? data.errors.join(', ')
                        : data?.message || 'Unable to save the new order.';
                    throw new Error(message);
                }
                showActionMessage('Timetable order updated successfully.', 'success');
                await loadBuses();
            } catch (error) {
                console.error('Reorder failed', error);
                showActionMessage(`Unable to save the new order: ${describeError(error)}`, 'error');
                loadBuses();
            }
        }

        function handleEditBus(busId) {
            if (!busId) return;
            const bus = state.buses.find(item => item.id === busId);
            if (bus) {
                openModal('Edit Bus', bus, busId);
                return;
            }
            showActionMessage('Unable to load the selected bus. Please refresh and try again.', 'error');
            loadBuses();
        }

        async function handleDeleteBus(busId) {
            if (!busId) return;
            if (!confirm('Are you sure you want to delete this bus?')) return;
            try {
                const response = await fetchWithAuth(`/api/buses/${busId}`, { method: 'DELETE' });
                if (!response.ok && response.status !== 204) {
                    const data = await response.json().catch(() => null);
                    const message = (Array.isArray(data?.errors) && data.errors.length)
                        ? data.errors.join(', ')
                        : data?.message || 'Unable to delete the selected bus.';
                    throw new Error(message);
                }
                showActionMessage('Bus deleted successfully.', 'success');
                await loadBuses();
            } catch (error) {
                console.error('Failed to delete bus:', error);
                showActionMessage(`Unable to delete the selected bus: ${describeError(error)}`, 'error');
                loadBuses();
            }
        }

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(totalMinutes) {
            const normalized = ((totalMinutes % (24 * 60)) + (24 * 60)) % (24 * 60);
            const hours = String(Math.floor(normalized / 60)).padStart(2, '0');
            const minutes = String(normalized % 60).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        function addMinutes(time, duration) {
            if (!time || !duration) return '';
            return minutesToTime(timeToMinutes(time) + Number(duration));
        }

        function generateDepartures(startTime, endTime, frequency) {
            const start = timeToMinutes(startTime);
            const end = timeToMinutes(endTime);
            const freq = Number(frequency);
            if (!startTime || !endTime || !freq || freq <= 0 || end < start) {
                return [];
            }
            const departures = [];
            for (let current = start; current <= end; current += freq) {
                departures.push(minutesToTime(current));
            }
            return departures;
        }

        function clearPriceMatrixState() {
            priceLookup.clear();
            priceEntryByKey.clear();
            locationSet.clear();
            if (locationOptionsList) locationOptionsList.innerHTML = '';
            if (priceMatrixBody) priceMatrixBody.innerHTML = '';
            if (priceMatrixEmpty) priceMatrixEmpty.classList.remove('hidden');
            if (priceFormMessage) {
                priceFormMessage.textContent = '';
                priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium';
            }
            if (priceEntryIdInput) priceEntryIdInput.value = '';
        }

        function updateLocationOptions() {
            if (!locationOptionsList) return;
            locationOptionsList.innerHTML = '';
            Array.from(locationSet)
                .sort((a, b) => a.localeCompare(b))
                .forEach(location => {
                    const option = document.createElement('option');
                    option.value = location;
                    locationOptionsList.appendChild(option);
                });
        }

        function renderPriceMatrix(entries) {
            if (!priceMatrixBody) return;
            priceMatrixBody.innerHTML = '';
            if (!entries.length) {
                if (priceMatrixEmpty) priceMatrixEmpty.classList.remove('hidden');
                return;
            }
            if (priceMatrixEmpty) priceMatrixEmpty.classList.add('hidden');
            entries.forEach(entry => {
                const tr = document.createElement('tr');
                tr.dataset.id = entry.id;
                const updatedAt = entry.updatedAt ? new Date(entry.updatedAt.seconds ? entry.updatedAt.seconds * 1000 : entry.updatedAt).toLocaleString() : '—';
                tr.innerHTML = `
                    <td class="px-4 py-3 whitespace-nowrap font-medium text-gray-800">${entry.origin}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-gray-700">${entry.destination}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-indigo-600 font-semibold">${entry.price || '—'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-xs text-gray-500">${updatedAt}</td>
                    <td class="px-4 py-3 whitespace-nowrap">
                        <button class="text-indigo-600 hover:text-indigo-900 price-edit" data-id="${entry.id}">Edit</button>
                        <button class="text-red-600 hover:text-red-900 price-delete ml-4" data-id="${entry.id}">Delete</button>
                    </td>`;
                priceMatrixBody.appendChild(tr);
            });
        }

        function maybeFillPrice({ origin, destination, price }) {
            const originVal = origin.value.trim();
            const destinationVal = destination.value.trim();
            if (!originVal || !destinationVal) return;
            const key = `${originVal.toLowerCase()}__${destinationVal.toLowerCase()}`;
            if (!priceLookup.has(key)) return;
            if (!price.value.trim() || price.dataset.autofilled === 'true') {
                price.value = priceLookup.get(key);
                price.dataset.autofilled = 'true';
            }
        }

        function autoFillPriceFields() {
            if (priceAutoFillRegistered) return;
            const pairs = [
                { origin: departsFromInput, destination: arrivesAtInput, price: priceInput },
                { origin: bulkDepartsFromInput, destination: bulkArrivesAtInput, price: bulkPriceInput }
            ].filter(pair => pair.origin && pair.destination && pair.price);

            pairs.forEach(pair => {
                if (!pair.price.dataset) pair.price.dataset = {};
                pair.price.addEventListener('input', () => {
                    pair.price.dataset.autofilled = 'false';
                });
                ['change', 'blur'].forEach(evt => {
                    pair.origin.addEventListener(evt, () => maybeFillPrice(pair));
                    pair.destination.addEventListener(evt, () => maybeFillPrice(pair));
                });
            });

            priceAutoFillRegistered = true;
        }

        function refreshPriceMatrix(entries) {
            priceLookup.clear();
            priceEntryByKey.clear();
            locationSet.clear();
            entries.forEach(entry => {
                const origin = (entry.origin || '').trim();
                const destination = (entry.destination || '').trim();
                if (!origin || !destination) return;
                locationSet.add(origin);
                locationSet.add(destination);
                const key = `${origin.toLowerCase()}__${destination.toLowerCase()}`;
                priceLookup.set(key, entry.price || '');
                priceEntryByKey.set(key, entry.id);
            });
            updateLocationOptions();
            renderPriceMatrix(entries);
            autoFillPriceFields();
        }

        function startPriceMatrixListener() {
            if (priceMatrixUnsubscribe) {
                priceMatrixUnsubscribe();
                priceMatrixUnsubscribe = null;
            }
            const priceMatrixQuery = query(collection(db, 'priceMatrix'), orderBy('origin'));
            priceMatrixUnsubscribe = onSnapshot(priceMatrixQuery, snapshot => {
                const entries = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
                refreshPriceMatrix(entries);
            }, error => {
                console.error('Error loading price matrix:', error);
                showActionMessage(`Failed to load price matrix: ${describeError(error)}`, 'error');
                if (priceFormMessage) {
                    priceFormMessage.textContent = 'Unable to load price matrix. Check console logs.';
                    priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium text-red-600';
                }
            });
        }

        function normalizeRole(role) {
            const value = (role || '').toString().trim().toLowerCase();
            if (value === 'administrator') return 'admin';
            if (value === 'timekeepers') return 'timekeeper';
            return value;
        }

        function extractRoleFromClaims(claims, allowedRoles) {
            if (!claims) return '';
            const sources = [
                claims.role,
                claims.userRole,
                claims.customRole,
                ...(Array.isArray(claims.roles) ? claims.roles : []),
                ...(Array.isArray(claims.permissions) ? claims.permissions : [])
            ];
            for (const entry of sources) {
                const normalized = normalizeRole(entry);
                if (!normalized) continue;
                if (!allowedRoles.length || allowedRoles.includes(normalized)) {
                    return normalized;
                }
            }
            return '';
        }

        async function maybeBackfillEmailLower(usersCollection, profile, emailLower) {
            if (!profile || !profile.id || !emailLower) return profile;
            if ((profile.emailLower || '').toString().toLowerCase() === emailLower) {
                return profile;
            }
            try {
                await setDoc(doc(usersCollection, profile.id), { emailLower }, { merge: true });
                profile.emailLower = emailLower;
            } catch (error) {
                console.warn('Unable to backfill lowercase email for user profile:', error);
                showActionMessage(`Unable to sync user email alias: ${describeError(error)}`, 'warning');
            }
            return profile;
        }

        async function ensureProfileFromClaims(user, role) {
            if (!user) return;
            const usersCollection = collection(db, 'users');
            const email = (user.email || '').trim();
            const payload = {
                role,
                email,
                emailLower: email.toLowerCase(),
                displayName: user.displayName || '',
                syncedFromClaims: true,
                updatedAt: serverTimestamp()
            };
            try {
                await setDoc(doc(usersCollection, user.uid), payload, { merge: true });
            } catch (error) {
                console.warn('Unable to seed Firestore profile from custom claims:', error);
                showActionMessage(`Unable to sync your profile from permissions: ${describeError(error)}`, 'warning');
            }
        }

        async function fetchUserProfile(user) {
            if (!user) return null;
            const email = (user.email || '').trim();
            const emailLower = email.toLowerCase();
            const usersCollection = collection(db, 'users');

            const tryDoc = async (docId) => {
                if (!docId) return null;
                const docRef = doc(usersCollection, docId);
                const docSnap = await getDoc(docRef);
                return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } : null;
            };

            try {
                let profile = await tryDoc(user.uid);
                if (profile) return maybeBackfillEmailLower(usersCollection, profile, emailLower);

                profile = await tryDoc(email);
                if (profile) return maybeBackfillEmailLower(usersCollection, profile, emailLower);

                if (emailLower !== email) {
                    profile = await tryDoc(emailLower);
                    if (profile) return maybeBackfillEmailLower(usersCollection, profile, emailLower);
                }

                if (email) {
                    let snapshot = await getDocs(query(usersCollection, where('emailLower', '==', emailLower), limit(1)));
                    if (!snapshot.empty) {
                        const docSnap = snapshot.docs[0];
                        return maybeBackfillEmailLower(usersCollection, { id: docSnap.id, ...docSnap.data() }, emailLower);
                    }

                    snapshot = await getDocs(query(usersCollection, where('email', '==', email), limit(1)));
                    if (!snapshot.empty) {
                        const docSnap = snapshot.docs[0];
                        return maybeBackfillEmailLower(usersCollection, { id: docSnap.id, ...docSnap.data() }, emailLower);
                    }
                }

                return null;
            } catch (error) {
                console.error('Error fetching user profile:', error);
                showActionMessage(`Error fetching user profile: ${describeError(error)}`, 'error');
                throw error;
            }
        }

        async function resolveRole(user, allowedRoles) {
            const profile = await fetchUserProfile(user);
            const profileRole = normalizeRole(profile?.role);
            if (profileRole && (!allowedRoles.length || allowedRoles.includes(profileRole))) {
                return { role: profileRole, profile };
            }

            try {
                const token = await user.getIdTokenResult(true);
                const claimRole = extractRoleFromClaims(token?.claims, allowedRoles);
                if (claimRole) {
                    await ensureProfileFromClaims(user, claimRole);
                    const refreshedProfile = profile || await fetchUserProfile(user);
                    return { role: claimRole, profile: refreshedProfile || profile };
                }
            } catch (error) {
                console.warn('Unable to resolve role from custom claims:', error);
                showActionMessage(`Unable to resolve your access permissions: ${describeError(error)}`, 'warning');
            }

            return { role: profileRole || null, profile };
        }

        renderAvailabilityCheckboxes(availabilityContainer);
        renderAvailabilityCheckboxes(bulkAvailabilityContainer);

        if (showAddModalButton) {
            showAddModalButton.addEventListener('click', () => openModal('Add New Bus'));
        }
        if (closeModalButton) {
            closeModalButton.addEventListener('click', closeBusModal);
        }
        if (showBulkAddModalButton) {
            showBulkAddModalButton.addEventListener('click', () => {
                if (bulkAddModal) bulkAddModal.classList.remove('hidden');
                if (bulkAddMessage) {
                    bulkAddMessage.textContent = '';
                    bulkAddMessage.className = 'text-sm font-medium';
                }
            });
        }
        if (closeBulkModalButton) {
            closeBulkModalButton.addEventListener('click', closeBulkModal);
        }

        if (busForm) {
            busForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (formError) formError.textContent = '';
                const payload = collectBusFormData();
                if (!payload) return;

                try {
                    const busId = busForm.dataset.busId;
                    const isUpdate = Boolean(busId);
                    const response = await fetchWithAuth(isUpdate ? `/api/buses/${busId}` : '/api/buses', {
                        method: isUpdate ? 'PUT' : 'POST',
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json().catch(() => null);
                    if (!response.ok) {
                        const message = (Array.isArray(data?.errors) && data.errors.length)
                            ? data.errors.join(', ')
                            : data?.message || 'Unable to save bus.';
                        throw new Error(message);
                    }
                    closeBusModal();
                    showActionMessage(isUpdate ? 'Bus updated successfully.' : 'Bus added successfully.', 'success');
                    await loadBuses();
                } catch (error) {
                    console.error('Failed to save bus:', error);
                    if (formError) {
                        formError.textContent = 'Unable to save bus. Please try again.';
                    }
                    showActionMessage(`Unable to save bus: ${describeError(error)}`, 'error');
                }
            });
        }

        if (bulkBusForm) {
            bulkBusForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (bulkAddMessage) {
                    bulkAddMessage.textContent = '';
                    bulkAddMessage.className = 'text-sm font-medium';
                }

                const routeBase = bulkRouteInput ? bulkRouteInput.value.trim() : '';
                const operator = bulkOperatorInput ? bulkOperatorInput.value.trim() : '';
                const departsFrom = bulkDepartsFromInput ? bulkDepartsFromInput.value.trim() : '';
                const arrivesAt = bulkArrivesAtInput ? bulkArrivesAtInput.value.trim() : '';
                const price = bulkPriceInput ? bulkPriceInput.value.trim() : '';
                const expresswayEntrance = bulkExpresswayEntranceInput ? bulkExpresswayEntranceInput.value.trim() : '';
                const expresswayExit = bulkExpresswayExitInput ? bulkExpresswayExitInput.value.trim() : '';
                const startTime = bulkStartTimeInput ? bulkStartTimeInput.value : '';
                const endTime = bulkEndTimeInput ? bulkEndTimeInput.value : '';
                const frequency = bulkFrequencyInput ? Number(bulkFrequencyInput.value) : 0;
                const duration = bulkDurationInput ? Number(bulkDurationInput.value) : 0;
                const availability = getSelectedDays(bulkAvailabilityContainer);
                const stops = parseStops(bulkStopsTextarea ? bulkStopsTextarea.value : '');

                if (!routeBase || !operator || !departsFrom || !arrivesAt || !startTime || !endTime || !frequency || frequency <= 0 || !duration || duration <= 0) {
                    if (bulkAddMessage) {
                        bulkAddMessage.textContent = 'Please fill in all required fields with valid values.';
                        bulkAddMessage.className = 'text-sm font-medium text-red-600';
                    }
                    showActionMessage('Please provide all required bulk add details before submitting.', 'error');
                    return;
                }

                const departures = generateDepartures(startTime, endTime, frequency);
                if (!departures.length) {
                    if (bulkAddMessage) {
                        bulkAddMessage.textContent = 'No departures generated. Check your start/end times and frequency.';
                        bulkAddMessage.className = 'text-sm font-medium text-red-600';
                    }
                    showActionMessage('No departures generated. Adjust start/end times or frequency.', 'error');
                    return;
                }

                try {
                    let createdCount = 0;
                    for (const departureTime of departures) {
                        const response = await fetchWithAuth('/api/buses', {
                            method: 'POST',
                            body: JSON.stringify({
                                route: routeBase,
                                operator,
                                departsFrom,
                                arrivesAt,
                                departureTime,
                                arrivalTime: addMinutes(departureTime, duration),
                                price,
                                expresswayEntrance,
                                expresswayExit,
                                availability,
                                stops
                            })
                        });
                        const data = await response.json().catch(() => null);
                        if (!response.ok) {
                            const message = (Array.isArray(data?.errors) && data.errors.length)
                                ? data.errors.join(', ')
                                : data?.message || 'Failed to add one of the buses.';
                            throw new Error(message);
                        }
                        createdCount += 1;
                    }
                    if (bulkAddMessage) {
                        bulkAddMessage.textContent = `Added ${createdCount} departures.`;
                        bulkAddMessage.className = 'text-sm font-medium text-green-600';
                    }
                    closeBulkModal();
                    showActionMessage(`Added ${createdCount} departures successfully.`, 'success');
                    await loadBuses();
                } catch (error) {
                    console.error('Failed to bulk add buses:', error);
                    if (bulkAddMessage) {
                        bulkAddMessage.textContent = 'Failed to add buses. Please try again.';
                        bulkAddMessage.className = 'text-sm font-medium text-red-600';
                    }
                    showActionMessage(`Failed to add buses: ${describeError(error)}`, 'error');
                    loadBuses();
                }
            });
        }

        if (priceForm) {
            priceForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (!priceOriginInput || !priceDestinationInput || !priceAmountInput) return;

                const origin = priceOriginInput.value.trim();
                const destination = priceDestinationInput.value.trim();
                const priceValue = priceAmountInput.value.trim();

                if (!origin || !destination || !priceValue) {
                    if (priceFormMessage) {
                        priceFormMessage.textContent = 'Please complete all fields.';
                        priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium text-red-600';
                    }
                    showActionMessage('Please complete all price matrix fields before saving.', 'error');
                    return;
                }

                const payload = {
                    origin,
                    destination,
                    price: priceValue,
                    updatedAt: serverTimestamp(),
                    updatedBy: currentUser ? currentUser.uid : null
                };

                try {
                    let actionLabel = 'Price entry saved.';
                    if (priceEntryIdInput && priceEntryIdInput.value) {
                        await setDoc(doc(db, 'priceMatrix', priceEntryIdInput.value), payload, { merge: true });
                        if (priceFormMessage) {
                            priceFormMessage.textContent = 'Price entry updated.';
                        }
                        actionLabel = 'Price entry updated.';
                    } else {
                        const key = `${origin.toLowerCase()}__${destination.toLowerCase()}`;
                        const existingId = priceEntryByKey.get(key);
                        if (existingId) {
                            await setDoc(doc(db, 'priceMatrix', existingId), payload, { merge: true });
                            if (priceFormMessage) {
                                priceFormMessage.textContent = 'Existing price updated.';
                            }
                            actionLabel = 'Existing price updated.';
                        } else {
                            await addDoc(collection(db, 'priceMatrix'), payload);
                            if (priceFormMessage) {
                                priceFormMessage.textContent = 'Price entry saved.';
                            }
                        }
                    }
                    if (priceFormMessage) {
                        priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium text-green-600';
                    }
                    priceForm.reset();
                    if (priceEntryIdInput) priceEntryIdInput.value = '';
                    if (priceAmountInput && priceAmountInput.dataset) {
                        priceAmountInput.dataset.autofilled = 'false';
                    }
                    showActionMessage(actionLabel, 'success');
                } catch (error) {
                    console.error('Error saving price entry:', error);
                    if (priceFormMessage) {
                        priceFormMessage.textContent = 'Failed to save price entry. Try again.';
                        priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium text-red-600';
                    }
                    showActionMessage(`Failed to save price entry: ${describeError(error)}`, 'error');
                }
            });
        }

        if (priceFormReset) {
            priceFormReset.addEventListener('click', () => {
                if (priceForm) priceForm.reset();
                if (priceEntryIdInput) priceEntryIdInput.value = '';
                if (priceFormMessage) {
                    priceFormMessage.textContent = '';
                    priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium';
                }
            });
        }

        if (priceMatrixBody) {
            priceMatrixBody.addEventListener('click', async (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const rowId = target.dataset.id;
                if (!rowId) return;

                if (target.classList.contains('price-edit')) {
                    try {
                        const docRef = doc(db, 'priceMatrix', rowId);
                        const docSnap = await getDoc(docRef);
                        if (!docSnap.exists()) {
                            showActionMessage('Selected price entry was already removed.', 'warning');
                            return;
                        }
                        const data = docSnap.data();
                        if (priceOriginInput) priceOriginInput.value = data.origin || '';
                        if (priceDestinationInput) priceDestinationInput.value = data.destination || '';
                        if (priceAmountInput) {
                            priceAmountInput.value = data.price || '';
                            priceAmountInput.dataset.autofilled = 'false';
                        }
                        if (priceEntryIdInput) priceEntryIdInput.value = rowId;
                        if (priceFormMessage) {
                            priceFormMessage.textContent = 'Editing existing entry. Save to update or Clear to cancel.';
                            priceFormMessage.className = 'md:col-span-2 lg:col-span-1 text-sm font-medium text-indigo-600';
                        }
                    } catch (error) {
                        console.error('Failed to load price entry for editing:', error);
                        showActionMessage(`Failed to load price entry for editing: ${describeError(error)}`, 'error');
                    }
                }

                if (target.classList.contains('price-delete')) {
                    if (confirm('Delete this price entry?')) {
                        try {
                            await deleteDoc(doc(db, 'priceMatrix', rowId));
                            showActionMessage('Price entry deleted successfully.', 'success');
                        } catch (error) {
                            console.error('Failed to delete price entry:', error);
                            showActionMessage(`Failed to delete price entry: ${describeError(error)}`, 'error');
                        }
                    }
                }
            });
        }

        if (refreshButton) {
            refreshButton.addEventListener('click', () => loadBuses());
        }

        if (refreshMatrixButton) {
            refreshMatrixButton.addEventListener('click', () => {
                clearPriceMatrixState();
                startPriceMatrixListener();
            });
        }

        if (loginForm) {
            loginForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    const loginError = document.getElementById('login-error');
                    if (loginError) loginError.textContent = '';
                } catch (error) {
                    console.error('Login failed:', error);
                    const loginError = document.getElementById('login-error');
                    const loginErrorMessage = error && error.message ? error.message : 'Unable to sign in. Please try again.';
                    if (loginError) loginError.textContent = loginErrorMessage;
                    showActionMessage(`Login failed: ${loginErrorMessage}`, 'error');
                }
            });
        }

        if (logoutButton) {
            logoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error('Failed to sign out:', error);
                    showActionMessage(`Failed to sign out: ${describeError(error)}`, 'error');
                }
            });
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                try {
                    const { role } = await resolveRole(user, ['admin']);
                    if (role === 'admin') {
                        currentUser = user;
                        apiTokenPromise = null;
                        if (loginScreen) loginScreen.classList.add('hidden');
                        if (dashboard) dashboard.classList.remove('hidden');
                        clearActionMessage();
                        loadBuses();
                        startPriceMatrixListener();
                    } else {
                        const denialMessage = 'Access Denied. You must be an administrator to view this page.';
                        alert(denialMessage);
                        showActionMessage(denialMessage, 'error');
                        await signOut(auth);
                    }
                } catch (error) {
                    const errorMessage = 'Unable to verify your permissions. Please try again or contact support.';
                    alert(errorMessage);
                    const detail = describeError(error, '');
                    showActionMessage(detail ? `${errorMessage} ${detail}`.trim() : errorMessage, 'error');
                    await signOut(auth);
                }
            } else {
                currentUser = null;
                apiTokenPromise = null;
                if (loginScreen) loginScreen.classList.remove('hidden');
                if (dashboard) dashboard.classList.add('hidden');
                if (unsubscribe) {
                    unsubscribe();
                    unsubscribe = null;
                }
                if (priceMatrixUnsubscribe) {
                    priceMatrixUnsubscribe();
                    priceMatrixUnsubscribe = null;
                }
                clearPriceMatrixState();
                clearActionMessage();
                if (state.sortable) {
                    state.sortable.destroy();
                    state.sortable = null;
                }
            }
        });
    }
    </script>
</body>
</html>
