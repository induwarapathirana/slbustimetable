<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Keeper Panel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-gray-100">

    <div id="login-screen" class="min-h-screen flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
            <h2 class="text-2xl font-bold text-center mb-6">Time Keeper Login</h2>
            <form id="login-form" class="space-y-4">
                <div>
                    <label for="email" class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="email" autocomplete="email" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
                </div>
                <div>
                    <label for="password" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="password" autocomplete="current-password" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
                </div>
                <button type="submit" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Login</button>
                <p id="login-error" class="text-red-500 text-sm text-center"></p>
            </form>
        </div>
    </div>

    <div id="dashboard" class="hidden container mx-auto p-4 md:p-6">
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-2xl font-bold">Daily Schedule: <span id="depot-name" class="text-indigo-600"></span></h1>
            <button id="logout-button" class="bg-red-500 text-white py-2 px-4 rounded-md hover:bg-red-600">Logout</button>
        </header>

        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
                <div>
                    <h2 class="text-xl font-bold">Schedule for <span id="selected-date-label" class="text-indigo-600"></span></h2>
                    <p class="text-sm text-gray-500">Status updates apply only to the selected date and automatically revert afterwards.</p>
                </div>
                <div class="flex items-center gap-3">
                    <label for="schedule-date" class="text-sm font-semibold text-gray-700">Select Date</label>
                    <input type="date" id="schedule-date" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
            </div>
            <div class="mt-4 flex items-center gap-2 text-xs text-gray-500">
                <span class="inline-flex items-center justify-center w-2.5 h-2.5 rounded-full bg-green-500"></span>
                <span>Tap a status to update it for this day. Choose "Scheduled" to clear overrides.</span>
            </div>
            <div id="schedule-container" class="space-y-4 mt-4">
                <!-- Schedule items will be inserted here -->
            </div>
            <div id="schedule-container" class="space-y-4"></div>
        </div>

        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-bold mb-4">Add Unscheduled Bus</h2>
            <p class="text-sm text-gray-500 mb-4">Create a one-off service for the selected date or add a permanent timetable entry using your depot presets.</p>
            <form id="add-bus-form" class="space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <input type="text" placeholder="Route (e.g., EX1/extra)" id="add-route" class="w-full p-2 border rounded" required>
                    <input type="text" placeholder="Operator" id="add-operator" class="w-full p-2 border rounded" required>
                    <input type="text" placeholder="Departs From" id="add-departsFrom" class="w-full p-2 border rounded" list="timekeeper-location-options" required>
                    <input type="text" placeholder="Arrives At" id="add-arrivesAt" class="w-full p-2 border rounded" list="timekeeper-location-options" required>
                    <input type="time" id="add-departureTime" class="w-full p-2 border rounded" required>
                    <input type="time" id="add-arrivalTime" class="w-full p-2 border rounded" placeholder="Arrival Time">
                    <input type="text" placeholder="Price" id="add-price" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Expressway Entrance" id="add-expresswayEntrance" class="w-full p-2 border rounded">
                    <input type="text" placeholder="Expressway Exit" id="add-expresswayExit" class="w-full p-2 border rounded">
                </div>

                <div>
                    <label class="font-semibold text-sm text-gray-700">Availability</label>
                    <div id="add-availability" class="mt-2 grid grid-cols-2 md:grid-cols-4 gap-2"></div>
                </div>

                <div>
                    <label class="font-semibold text-sm text-gray-700">Intermediate Stops (one per line)</label>
                    <textarea id="add-stops" rows="3" class="w-full p-2 border rounded"></textarea>
                </div>

                <fieldset class="border border-gray-200 rounded-md p-4">
                    <legend class="px-2 text-sm font-semibold text-gray-700">How long should this bus stay in the timetable?</legend>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mt-2 text-sm">
                        <label class="flex items-start gap-2">
                            <input type="radio" name="bus-duration" value="single-day" class="mt-1" checked>
                            <span>
                                Single day only (adds to <span class="font-semibold" id="single-day-label"></span>)
                                <span class="block text-gray-500">The bus will appear only on the selected date.</span>
                            </span>
                        </label>
                        <label class="flex items-start gap-2">
                            <input type="radio" name="bus-duration" value="permanent" class="mt-1">
                            <span>
                                Keep permanently
                                <span class="block text-gray-500">Uses the availability days above for ongoing departures.</span>
                            </span>
                        </label>
                    </div>
                </fieldset>

                <p id="add-bus-message" class="text-sm font-medium"></p>

                <div class="flex justify-end">
                    <button type="submit" class="bg-blue-500 text-white py-2 px-6 rounded-md hover:bg-blue-600">Add Bus</button>
                </div>
                <p id="add-bus-message" class="text-sm"></p>
            </form>
        </div>

        <datalist id="timekeeper-locations"></datalist>
    </div>

    <datalist id="timekeeper-location-options"></datalist>

    <script type="module">
        import { getApp, getApps, initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
        import {
            getFirestore,
            addDoc,
            collection,
            deleteDoc,
            doc,
            getDoc,
            getDocs,
            limit,
            onSnapshot,
            orderBy,
            query,
            serverTimestamp,
            setDoc,
            where
        } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

        // This is the correct format. Just paste your values here.
        // --- Firebase bootstrap -------------------------------------------------
        // Swap in your project-specific keys below; keep the property names so the
        // shared helper functions can initialise Firebase without extra changes.
        const firebaseConfig = {
        apiKey: "AIzaSyArXmYmU6l4t_xaNquhT0JUH4sG2ge3tZo",
        authDomain: "bustimetable-v2.firebaseapp.com",
        projectId: "bustimetable-v2",
        storageBucket: "bustimetable-v2.firebasestorage.app",
        messagingSenderId: "665985152111",
        appId: "1:665985152111:web:291020ebb619374c4f899a",
        measurementId: "G-0EEKT7RR6R"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const TOKEN_KEY = 'slbustimetable:token';
        const state = {
            token: localStorage.getItem(TOKEN_KEY) || null,
            user: null,
            schedule: []
        };

            // Rehydrate an existing Firebase app when the timekeeper dashboard reloads
            // via the emulator or Hot Reload, otherwise create a brand new instance.
            const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);

            // DOM Elements
            const loginScreen = document.getElementById('login-screen');
            const dashboard = document.getElementById('dashboard');
            const loginForm = document.getElementById('login-form');
            const logoutButton = document.getElementById('logout-button');
            const scheduleContainer = document.getElementById('schedule-container');
            const depotNameEl = document.getElementById('depot-name');
            const scheduleDateInput = document.getElementById('schedule-date');
            const selectedDateLabel = document.getElementById('selected-date-label');
            const singleDayLabel = document.getElementById('single-day-label');
            const addBusForm = document.getElementById('add-bus-form');
            const addBusMessage = document.getElementById('add-bus-message');
            const addRouteInput = document.getElementById('add-route');
            const addOperatorInput = document.getElementById('add-operator');
            const addDepartsFromInput = document.getElementById('add-departsFrom');
            const addArrivesAtInput = document.getElementById('add-arrivesAt');
            const addDepartureTimeInput = document.getElementById('add-departureTime');
            const addArrivalTimeInput = document.getElementById('add-arrivalTime');
            const addPriceInput = document.getElementById('add-price');
            const addExpresswayEntranceInput = document.getElementById('add-expresswayEntrance');
            const addExpresswayExitInput = document.getElementById('add-expresswayExit');
            const addStopsInput = document.getElementById('add-stops');
            const addAvailabilityContainer = document.getElementById('add-availability');
            const locationOptionsList = document.getElementById('timekeeper-location-options');

            let currentUser = null;
            let userDepot = null;
            let unsubscribe = null;
            let overrideUnsubscribe = null;
            let priceMatrixUnsubscribe = null;
            let locationUnsubscribe = null;

            let latestBuses = [];
            let statusOverrides = new Map();
            let selectedDate = null;

            const priceLookup = new Map();
            const locationSet = new Set();
            let priceAutoFillRegistered = false;
            const daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
            const statusOptions = ["Scheduled", "Departed", "Arrived", "Delayed", "Cancelled"];
            const statusStyles = {
                "Scheduled": "border-gray-300 text-gray-700 bg-white hover:bg-gray-50",
                "Departed": "border-green-500 text-green-700 bg-green-50 hover:bg-green-100",
                "Arrived": "border-blue-500 text-blue-700 bg-blue-50 hover:bg-blue-100",
                "Delayed": "border-yellow-500 text-yellow-700 bg-yellow-50 hover:bg-yellow-100",
                "Cancelled": "border-red-500 text-red-700 bg-red-50 hover:bg-red-100"
            };

            function normalizeRole(role) {
                const value = (role || '').toString().trim().toLowerCase();
                if (value === 'administrator') return 'admin';
                if (value === 'timekeepers') return 'timekeeper';
                return value;
            }

            function extractRoleFromClaims(claims, allowedRoles) {
                if (!claims) return '';
                const sources = [
                    claims.role,
                    claims.userRole,
                    claims.customRole,
                    ...(Array.isArray(claims.roles) ? claims.roles : []),
                    ...(Array.isArray(claims.permissions) ? claims.permissions : [])
                ];
                for (const entry of sources) {
                    const normalized = normalizeRole(entry);
                    if (!normalized) continue;
                    if (!allowedRoles.length || allowedRoles.includes(normalized)) {
                        return normalized;
                    }
                }
                return '';
            }

            async function maybeBackfillEmailLower(usersCollection, profile, emailLower) {
                if (!profile || !profile.id || !emailLower) return profile;
                if ((profile.emailLower || '').toString().toLowerCase() === emailLower) {
                    return profile;
                }
                try {
                    await setDoc(doc(usersCollection, profile.id), { emailLower }, { merge: true });
                    profile.emailLower = emailLower;
                } catch (error) {
                    console.warn('Unable to backfill lowercase email for user profile:', error);
                }
                return profile;
            }

            async function ensureProfileFromClaims(user, role) {
                if (!user) return;
                const usersCollection = collection(db, 'users');
                const email = (user.email || '').trim();
                const payload = {
                    role,
                    email,
                    emailLower: email.toLowerCase(),
                    displayName: user.displayName || '',
                    syncedFromClaims: true,
                    updatedAt: serverTimestamp()
                };
                try {
                    await setDoc(doc(usersCollection, user.uid), payload, { merge: true });
                } catch (error) {
                    console.warn('Unable to seed Firestore profile from custom claims:', error);
                }
            }

            async function resolveRole(user, allowedRoles) {
                const profile = await fetchUserProfile(user);
                const profileRole = normalizeRole(profile?.role);
                if (profileRole && (!allowedRoles.length || allowedRoles.includes(profileRole))) {
                    return { role: profileRole, profile };
                }

                try {
                    const token = await user.getIdTokenResult(true);
                    const claimRole = extractRoleFromClaims(token?.claims, allowedRoles);
                    if (claimRole) {
                        await ensureProfileFromClaims(user, claimRole);
                        const refreshedProfile = profile || await fetchUserProfile(user);
                        return { role: claimRole, profile: refreshedProfile || profile };
                    }
                } catch (error) {
                    console.warn('Unable to resolve role from custom claims:', error);
                }

                return { role: profileRole || null, profile };
            }

            async function fetchUserProfile(user) {
                if (!user) return null;
                const email = (user.email || '').trim();
                const emailLower = email.toLowerCase();

                const usersCollection = collection(db, 'users');

                const tryDoc = async (docId) => {
                    if (!docId) return null;
                    const docRef = doc(usersCollection, docId);
                    const docSnap = await getDoc(docRef);
                    return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } : null;
                };

                try {
                    let profile = await tryDoc(user.uid);
                    if (profile) return maybeBackfillEmailLower(usersCollection, profile, emailLower);

                    profile = await tryDoc(email);
                    if (profile) return maybeBackfillEmailLower(usersCollection, profile, emailLower);

                    if (emailLower !== email) {
                        profile = await tryDoc(emailLower);
                        if (profile) return maybeBackfillEmailLower(usersCollection, profile, emailLower);
                    }

                    if (email) {
                        let snapshot = await getDocs(query(usersCollection, where('emailLower', '==', emailLower), limit(1)));
                        if (!snapshot.empty) {
                            const docSnap = snapshot.docs[0];
                            return maybeBackfillEmailLower(usersCollection, { id: docSnap.id, ...docSnap.data() }, emailLower);
                        }

                        snapshot = await getDocs(query(usersCollection, where('email', '==', email), limit(1)));
                        if (!snapshot.empty) {
                            const docSnap = snapshot.docs[0];
                            return maybeBackfillEmailLower(usersCollection, { id: docSnap.id, ...docSnap.data() }, emailLower);
                        }
                    }

                    return null;
                } catch (error) {
                    console.error('Error fetching user profile:', error);
                    throw error;
                }
            }

            // --- AUTHENTICATION & ACCESS CONTROL ---
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    try {
                        const { role, profile } = await resolveRole(user, ['timekeeper', 'admin']);
                        if (role === 'timekeeper' || role === 'admin') {
                            currentUser = user;
                            const activeProfile = profile || await fetchUserProfile(user);
                            const rawDepot = activeProfile?.depot ?? activeProfile?.depotName ?? activeProfile?.location ?? '';
                            userDepot = rawDepot ? String(rawDepot) : '';
                            depotNameEl.textContent = userDepot || '—';
                            addDepartsFromInput.value = userDepot || '';
                            loginScreen.classList.add('hidden');
                            dashboard.classList.remove('hidden');
                            setupAvailabilityCheckboxes();
                            startLocationListener();
                            startPriceMatrixListener();
                            initializeDatePicker();
                            loadScheduleForSelectedDate();
                        } else {
                            alert('Access Denied. You must be a Time Keeper to view this page.');
                            await signOut(auth);
                        }
                    } catch (error) {
                        console.error("Permission error on login:", error);
                        alert('Error verifying your permissions. Please contact an administrator.');
                        await signOut(auth);
                    }
                } else {
                    currentUser = null;
                    userDepot = null;
                    loginScreen.classList.remove('hidden');
                    dashboard.classList.remove('hidden');
                    if (unsubscribe) unsubscribe();
                    if (overrideUnsubscribe) overrideUnsubscribe();
                    if (priceMatrixUnsubscribe) priceMatrixUnsubscribe();
                    if (locationUnsubscribe) locationUnsubscribe();
                    resetState();
                }
            });

            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;

                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    document.getElementById('login-error').textContent = '';
                } catch (error) {
                    document.getElementById('login-error').textContent = error.message;
                }
            });

            logoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error('Failed to sign out:', error);
                }
            });

            // --- DATA HANDLING ---
            function resetState() {
                latestBuses = [];
                statusOverrides = new Map();
                selectedDate = null;
                scheduleContainer.innerHTML = '';
                addBusForm.reset();
                addBusMessage.textContent = '';
                addBusMessage.className = 'text-sm font-medium';
                priceLookup.clear();
                locationSet.clear();
                updateLocationOptions();
                priceAutoFillRegistered = false;
                addDepartsFromInput.value = '';
            }

            function setupAvailabilityCheckboxes() {
                if (!addAvailabilityContainer) return;
                addAvailabilityContainer.innerHTML = '';
                daysOfWeek.forEach(day => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center gap-2 text-sm text-gray-700 bg-gray-50 border border-gray-200 rounded-md px-3 py-2';
                    label.innerHTML = `<input type="checkbox" value="${day}" class="rounded text-indigo-600 focus:ring-indigo-500"> ${day}`;
                    addAvailabilityContainer.appendChild(label);
                });
            }

            function startPriceMatrixListener() {
                if (priceMatrixUnsubscribe) priceMatrixUnsubscribe();
                const priceMatrixQuery = query(collection(db, 'priceMatrix'), orderBy('origin'));
                priceMatrixUnsubscribe = onSnapshot(priceMatrixQuery, snapshot => {
                    const entries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    refreshPriceMatrix(entries);
                }, error => {
                    console.error('Error loading price presets:', error);
                });
            }

            function refreshPriceMatrix(entries) {
                priceLookup.clear();
                locationSet.clear();
                entries.forEach(entry => {
                    const origin = (entry.origin || '').trim();
                    const destination = (entry.destination || '').trim();
                    if (!origin || !destination) return;
                    locationSet.add(origin);
                    locationSet.add(destination);
                    const key = `${origin.toLowerCase()}__${destination.toLowerCase()}`;
                    priceLookup.set(key, entry.price || '');
                });
                updateLocationOptions();
                autoFillPriceField();
                maybeFillTimekeeperPrice();
            }

            function startLocationListener() {
                if (locationUnsubscribe) locationUnsubscribe();
                locationUnsubscribe = onSnapshot(collection(db, 'buses'), snapshot => {
                    snapshot.docs.forEach(doc => {
                        const bus = doc.data();
                        if (bus.departsFrom) locationSet.add((bus.departsFrom || '').trim());
                        if (bus.arrivesAt) locationSet.add((bus.arrivesAt || '').trim());
                    });
                    updateLocationOptions();
                    maybeFillTimekeeperPrice();
                });
            }

            function updateLocationOptions() {
                if (!locationOptionsList) return;
                locationOptionsList.innerHTML = '';
                Array.from(locationSet).sort((a, b) => a.localeCompare(b)).forEach(location => {
                    const option = document.createElement('option');
                    option.value = location;
                    locationOptionsList.appendChild(option);
                });
            }

            function autoFillPriceField() {
                if (priceAutoFillRegistered) return;
                if (!addPriceInput) return;
                addPriceInput.dataset.autofilled = 'false';
                addPriceInput.addEventListener('input', () => {
                    addPriceInput.dataset.autofilled = 'false';
                });
                ['change', 'blur'].forEach(evt => {
                    addDepartsFromInput.addEventListener(evt, maybeFillTimekeeperPrice);
                    addArrivesAtInput.addEventListener(evt, maybeFillTimekeeperPrice);
                });
                priceAutoFillRegistered = true;
            }

            function maybeFillTimekeeperPrice() {
                if (!addDepartsFromInput || !addArrivesAtInput || !addPriceInput) return;
                const origin = addDepartsFromInput.value.trim();
                const destination = addArrivesAtInput.value.trim();
                if (!origin || !destination) return;
                const key = `${origin.toLowerCase()}__${destination.toLowerCase()}`;
                if (!priceLookup.has(key)) return;
                if (!addPriceInput.value.trim() || addPriceInput.dataset.autofilled === 'true') {
                    addPriceInput.value = priceLookup.get(key);
                    addPriceInput.dataset.autofilled = 'true';
                }
            }

            function initializeDatePicker() {
                if (!scheduleDateInput) return;
                const todayIso = formatDate(new Date());
                if (!scheduleDateInput.value) scheduleDateInput.value = todayIso;
                updateSelectedDateLabels(scheduleDateInput.value || todayIso);
                scheduleDateInput.addEventListener('change', () => {
                    updateSelectedDateLabels(scheduleDateInput.value);
                    loadScheduleForSelectedDate();
                });
            }

            function updateSelectedDateLabels(isoDate) {
                if (!isoDate) return;
                selectedDate = isoDate;
                if (selectedDateLabel) selectedDateLabel.textContent = formatHumanDate(isoDate);
                if (singleDayLabel) singleDayLabel.textContent = formatHumanDate(isoDate);
            }

            function loadScheduleForSelectedDate() {
                if (!userDepot) return;
                const isoDate = scheduleDateInput && scheduleDateInput.value ? scheduleDateInput.value : formatDate(new Date());
                const dayName = getWeekdayName(isoDate);
                selectedDate = isoDate;

                if (unsubscribe) unsubscribe();
                const scheduleQuery = query(
                    collection(db, 'buses'),
                    where('departsFrom', '==', userDepot)
                );
                unsubscribe = onSnapshot(scheduleQuery, snapshot => {
                        const allBuses = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        latestBuses = filterBusesForDate(allBuses, isoDate, dayName);
                        renderSchedule(latestBuses, statusOverrides);
                    }, error => {
                        console.error('Error fetching schedule:', error);
                        scheduleContainer.innerHTML = '<p class="text-center text-red-500">Unable to load schedule. Check console logs.</p>';
                    });

                if (overrideUnsubscribe) overrideUnsubscribe();
                const overrideQuery = query(
                    collection(db, 'busStatusOverrides'),
                    where('depot', '==', userDepot),
                    where('date', '==', isoDate)
                );
                overrideUnsubscribe = onSnapshot(overrideQuery, snapshot => {
                        const overrideMap = new Map();
                        snapshot.docs.forEach(doc => {
                            const data = doc.data();
                            overrideMap.set(data.busId, data);
                        });
                        statusOverrides = overrideMap;
                        renderSchedule(latestBuses, statusOverrides);
                    }, error => {
                        console.error('Error fetching overrides:', error);
                    });
            }

            function filterBusesForDate(buses, isoDate, dayName) {
                return buses
                    .filter(bus => {
                        const availability = bus.availability || [];
                        const specialDates = bus.specialDates || [];
                        return availability.includes(dayName) || specialDates.includes(isoDate);
                    })
                    .map(bus => ({
                        ...bus,
                        isSpecial: Array.isArray(bus.specialDates) && bus.specialDates.includes(isoDate)
                    }))
                    .sort((a, b) => compareTimes(a.departureTime, b.departureTime));
            }

            function compareTimes(a, b) {
                const toMinutes = (time) => {
                    if (!time) return Number.POSITIVE_INFINITY;
                    const [hours, minutes] = time.split(':').map(Number);
                    if (Number.isNaN(hours) || Number.isNaN(minutes)) return Number.POSITIVE_INFINITY;
                    return hours * 60 + minutes;
                };
                return toMinutes(a) - toMinutes(b);
            }

            function renderSchedule(buses, overridesMap) {
                scheduleContainer.innerHTML = '';
                if (!buses.length) {
                    scheduleContainer.innerHTML = '<p class="text-center text-gray-500">No departures scheduled for this date.</p>';
                    return;
                }

                buses.forEach(bus => {
                    const override = overridesMap.get(bus.id);
                    const status = override ? override.status : (bus.status || 'Scheduled');
                    const statusClass = statusStyles[status] || statusStyles['Scheduled'];
                    const isOverride = Boolean(override);
                    const card = document.createElement('div');
                    card.className = 'p-5 bg-white border border-gray-200 rounded-lg shadow-sm flex flex-col gap-3';
                    if (bus.isSpecial) {
                        card.classList.add('border-indigo-400', 'bg-indigo-50');
                    }
                    card.innerHTML = `
                        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
                            <div>
                                <p class="text-lg font-semibold text-gray-900">${bus.route || 'Unlabeled Route'}</p>
                                <p class="text-sm text-gray-600">${bus.operator || 'Unknown operator'}</p>
                            </div>
                            <div class="text-right">
                                <p class="text-sm text-gray-500">Departs</p>
                                <p class="text-xl font-bold text-gray-900">${bus.departureTime || 'TBD'}</p>
                                ${bus.arrivalTime ? `<p class="text-xs text-gray-500">Arrives ${bus.arrivalTime}</p>` : ''}
                            </div>
                        </div>
                        <div class="flex flex-wrap items-center gap-3 text-sm text-gray-600">
                            <span class="inline-flex items-center gap-2 px-3 py-1 rounded-full border ${statusClass} status-pill">
                                <span class="font-semibold">${status}</span>
                                ${isOverride ? '<span class="text-[0.65rem] uppercase tracking-wide text-indigo-600">Override</span>' : ''}
                            </span>
                            <span class="inline-flex items-center gap-1 px-3 py-1 rounded-full bg-gray-100 text-gray-700">${bus.departsFrom || userDepot} → ${bus.arrivesAt || ''}</span>
                            ${bus.price ? `<span class="inline-flex items-center gap-1 px-2.5 py-1 rounded-full bg-emerald-50 text-emerald-700 border border-emerald-200">${bus.price}</span>` : ''}
                            ${bus.isSpecial ? '<span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-indigo-600 text-white text-xs">Single-day</span>' : ''}
                        </div>
                        <div class="flex flex-wrap gap-2">
                            ${renderStatusButtons(status, bus.id)}
                        </div>
                    `;
                    scheduleContainer.appendChild(card);
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.message || 'Login failed');
                state.token = data.token;
                localStorage.setItem(TOKEN_KEY, data.token);
                toggleView();
            } catch (error) {
                loginError.textContent = error.message;
            }
        }

            function renderStatusButtons(activeStatus, busId) {
                return statusOptions.map(statusOption => {
                    const baseClass = statusStyles[statusOption] || statusStyles['Scheduled'];
                    const isActive = statusOption === activeStatus;
                    const activeClass = isActive ? 'ring-2 ring-offset-1 ring-indigo-500' : '';
                    return `<button type="button" data-id="${busId}" data-status="${statusOption}" class="status-btn px-3 py-1 rounded-full border text-xs font-semibold transition ${baseClass} ${activeClass}">${statusOption}</button>`;
                }).join('');
            }

            function formatHumanDate(isoDate) {
                const date = new Date(`${isoDate}T00:00:00`);
                if (Number.isNaN(date.getTime())) return isoDate;
                return date.toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' });
            }

            function formatDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            function getWeekdayName(isoDate) {
                const date = new Date(`${isoDate}T00:00:00`);
                return date.toLocaleDateString('en-US', { weekday: 'long' });
            }

            function formatHumanDate(isoDate) {
                const date = new Date(`${isoDate}T00:00:00`);
                if (Number.isNaN(date.getTime())) return isoDate;
                return date.toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' });
            }

            function formatDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            function getWeekdayName(isoDate) {
                const date = new Date(`${isoDate}T00:00:00`);
                return date.toLocaleDateString('en-US', { weekday: 'long' });
            }
        }

            scheduleContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.status-btn');
                if (!button) return;
                const busId = button.dataset.id;
                const newStatus = button.dataset.status;
                updateStatusForDate(busId, newStatus);
            });
        }

        function renderStatusPill(status) {
            const map = {
                'Scheduled': { badge: '<span class="px-2 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-700">Scheduled</span>', border: 'border-gray-300' },
                'Departed': { badge: '<span class="px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-700">Departed</span>', border: 'border-green-500' },
                'Arrived': { badge: '<span class="px-2 py-1 text-xs font-semibold rounded-full bg-blue-100 text-blue-700">Arrived</span>', border: 'border-blue-500' },
                'Delayed': { badge: '<span class="px-2 py-1 text-xs font-semibold rounded-full bg-yellow-100 text-yellow-700">Delayed</span>', border: 'border-yellow-500' },
                'Cancelled': { badge: '<span class="px-2 py-1 text-xs font-semibold rounded-full bg-red-100 text-red-700">Cancelled</span>', border: 'border-red-500' }
            };
            return map[status] || map['Scheduled'];
        }

            async function updateStatusForDate(busId, status) {
                if (!selectedDate || !busId) return;
                const docId = `${busId}_${selectedDate}`;
                const docRef = doc(db, 'busStatusOverrides', docId);
                try {
                    if (status === 'Scheduled') {
                        await deleteDoc(docRef);
                    } else {
                        await setDoc(docRef, {
                            busId,
                            date: selectedDate,
                            depot: userDepot,
                            status,
                            updatedAt: serverTimestamp(),
                            updatedBy: currentUser ? currentUser.uid : null
                        }, { merge: true });
                    }
                } catch (error) {
                    console.error('Error updating status override:', error);
                    alert('Unable to update status. Please try again.');
                }
            }

            async function updateStatusForDate(busId, status) {
                if (!selectedDate || !busId) return;
                const docId = `${busId}_${selectedDate}`;
                const docRef = doc(db, 'busStatusOverrides', docId);
                try {
                    if (status === 'Scheduled') {
                        await deleteDoc(docRef);
                    } else {
                        await setDoc(docRef, {
                            busId,
                            date: selectedDate,
                            depot: userDepot,
                            status,
                            updatedAt: serverTimestamp(),
                            updatedBy: currentUser ? currentUser.uid : null
                        }, { merge: true });
                    }
                } catch (error) {
                    console.error('Error updating status override:', error);
                    alert('Unable to update status. Please try again.');
                }
            }

            async function updateStatusForDate(busId, status) {
                if (!selectedDate || !busId) return;
                const docId = `${busId}_${selectedDate}`;
                const docRef = doc(db, 'busStatusOverrides', docId);
                try {
                    if (status === 'Scheduled') {
                        await deleteDoc(docRef);
                    } else {
                        await setDoc(docRef, {
                            busId,
                            date: selectedDate,
                            depot: userDepot,
                            status,
                            updatedAt: serverTimestamp(),
                            updatedBy: currentUser ? currentUser.uid : null
                        }, { merge: true });
                    }
                } catch (error) {
                    console.error('Error updating status override:', error);
                    alert('Unable to update status. Please try again.');
                }
            }

            // --- ADD UNSCHEDULED BUS ---
            addBusForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!userDepot) return;
                addBusMessage.textContent = '';
                addBusMessage.className = 'text-sm font-medium';
                const isoDate = selectedDate || (scheduleDateInput && scheduleDateInput.value) || formatDate(new Date());
                const mode = (document.querySelector('input[name="bus-duration"]:checked') || {}).value || 'single-day';
                const availability = Array.from(addAvailabilityContainer.querySelectorAll('input:checked')).map(cb => cb.value);

                if (mode === 'permanent' && availability.length === 0) {
                    addBusMessage.textContent = 'Select at least one availability day for permanent buses.';
                    addBusMessage.className = 'text-sm font-medium text-red-600';
                    return;
                }

                const stops = addStopsInput.value
                    .split('\n')
                    .map(stop => stop.trim())
                    .filter(Boolean);

                const newBus = {
                    route: addRouteInput.value.trim(),
                    operator: addOperatorInput.value.trim(),
                    departsFrom: addDepartsFromInput.value.trim() || userDepot,
                    arrivesAt: addArrivesAtInput.value.trim(),
                    departureTime: addDepartureTimeInput.value,
                    arrivalTime: addArrivalTimeInput.value,
                    price: addPriceInput.value.trim(),
                    expresswayEntrance: addExpresswayEntranceInput.value.trim(),
                    expresswayExit: addExpresswayExitInput.value.trim(),
                    stops,
                    availability: mode === 'permanent' ? availability : [],
                    status: 'Scheduled',
                    sortOrder: 9999,
                    createdAt: serverTimestamp(),
                    createdBy: currentUser ? currentUser.uid : null
                };

                if (mode === 'single-day') {
                    newBus.specialDates = [isoDate];
                    newBus.temporary = true;
                } else {
                    newBus.specialDates = newBus.specialDates || [];
                    newBus.temporary = false;
                }

                try {
                    await addDoc(collection(db, 'buses'), newBus);
                    addBusMessage.textContent = mode === 'single-day'
                        ? 'Temporary bus added for the selected date.'
                        : 'Bus added to the timetable.';
                    addBusMessage.className = 'text-sm font-medium text-green-600';
                    addBusForm.reset();
                    addDepartsFromInput.value = userDepot || '';
                    updateSelectedDateLabels(isoDate);
                } catch (error) {
                    console.error('Error adding bus:', error);
                    addBusMessage.textContent = 'Could not add bus. Please check the console for details.';
                    addBusMessage.className = 'text-sm font-medium text-red-600';
                }
                loadSchedule();
            } catch (error) {
                alert(error.message);
            }
        }

        async function handleAddBus(event) {
            event.preventDefault();
            addBusMessage.textContent = '';
            if (!state.user || !state.user.depot) {
                addBusMessage.textContent = 'Your profile is missing a depot assignment.';
                addBusMessage.className = 'text-sm text-red-600';
                return;
            }
            const payload = {
                route: document.getElementById('add-route').value.trim(),
                operator: document.getElementById('add-operator').value.trim(),
                arrivesAt: document.getElementById('add-arrivesAt').value.trim(),
                departureTime: document.getElementById('add-departureTime').value,
                arrivalTime: document.getElementById('add-arrivalTime').value,
                price: document.getElementById('add-price').value.trim(),
                availability: [new Date().toLocaleString('en-US', { weekday: 'long' })]
            };
            try {
                const response = await fetchWithAuth('/api/timekeeper/buses', {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error((data.errors && data.errors.join(', ')) || data.message || 'Failed to add bus');
                addBusMessage.textContent = `Added ${data.route} departure.`;
                addBusMessage.className = 'text-sm text-green-600';
                addBusForm.reset();
                loadSchedule();
            } catch (error) {
                addBusMessage.textContent = error.message;
                addBusMessage.className = 'text-sm text-red-600';
            }
        }

        loginForm.addEventListener('submit', handleLogin);
        logoutButton.addEventListener('click', handleLogout);
        refreshButton.addEventListener('click', loadSchedule);
        scheduleContainer.addEventListener('click', handleStatusChange);
        addBusForm.addEventListener('submit', handleAddBus);

        toggleView();
    </script>

</body>
</html>
